// ================================================================
// File: README.md
// ================================================================
// # Robust 3D Integration System for Next.js/React Projects
//
// **Generated by AI Assistant on:** [Current Date]
//
// ## Purpose
// This document outlines a standardized, reusable, and LLM-optimized system for incorporating 3D visuals into Next.js 15 / React 19 applications using Three.js, React Three Fiber (R3F), and Drei.
//
// ## System Goals
// - **Robustness:** Provide a stable foundation for various 3D features.
// - **Reusability:** Define clear components and structures applicable across multiple projects.
// - **Maintainability:** Ensure code is easy to understand, modify, and debug.
// - **Performance:** Incorporate best practices for efficient 3D rendering.
// - **LLM Optimization:** Structure code and documentation to be easily understood and manipulated by Large Language Models for faster development and prototyping via prompting.
//
// ## Core Technologies
// - **Next.js 15:** Framework for React applications (App Router assumed).
// - **React 19:** UI Library.
// - **Three.js:** The underlying 3D graphics library. [1]
// - **@react-three/fiber (R3F):** A React renderer for Three.js, enabling declarative scene graph construction within React components. [2]
// - **@react-three/drei:** A collection of useful helpers, abstractions, and ready-made components for R3F, significantly reducing boilerplate. [3]
// - **TypeScript:** For strong typing, improving code quality and LLM understanding.
//
// ## Structure Overview
// 1.  **Introduction & Core Concepts:** Basics of the chosen technologies.
// 2.  **Setup & Installation:** Required dependencies.
// 3.  **Project Structure:** Recommended directory layout.
// 4.  **Core Components & Patterns:** Essential building blocks (`Canvas`, custom components, loading models).
// 5.  **LLM Optimization Guidelines:** Best practices for prompting.
// 6.  **Example Implementation:** Concrete file structure and code examples (Repomix style).
// 7.  **Advanced Topics:** Pointers for post-processing, performance, etc.
//
// ---
//
// ## 1. Introduction & Core Concepts
//
// This system leverages the power of Three.js within the familiar React ecosystem through R3F.
//
// - **Three.js:** Provides the fundamental tools for creating 3D scenes: geometry, materials, lights, cameras, and the renderer. It's typically imperative. [1]
// - **React Three Fiber (R3F):** Acts as a bridge, allowing you to define your Three.js scene declaratively using React components. It manages the render loop, updates the scene based on state/prop changes, and integrates with the React lifecycle. [2]
// - **Drei:** Sits on top of R3F, offering pre-built solutions for common 3D tasks like adding controls (`<OrbitControls>`), loading models (`useGLTF`), setting up environments (`<Environment>`), and much more. Using Drei significantly accelerates development. [3]
//
// ## 2. Setup & Installation
//
// Ensure you have Node.js and npm/yarn/pnpm installed. In your Next.js project, install the core dependencies:
//
// ```bash
// npm install three @react-three/fiber @react-three/drei
// # or
// yarn add three @react-three/fiber @react-three/drei
// # or
// pnpm add three @react-three/fiber @react-three/drei
// ```
//
// For TypeScript projects (recommended), also install the types for Three.js:
//
// ```bash
// npm install -D @types/three
// # or
// yarn add -D @types/three
// # or
// pnpm add -D @types/three
// ```
//
// ## 3. Project Structure Recommendation
//
// A clear structure aids both humans and LLMs. Consider organizing your 3D-related code as follows:
//
// ```
// src/
// ├── app/                 # Next.js App Router pages
// │   └── ...
// ├── components/
// │   ├── ui/              # Standard UI components (e.g., Shadcn/ui)
// │   └── 3d/              # Reusable 3D components
// │       ├── CanvasWrapper.tsx # Optional: Wrapper for common Canvas setup
// │       ├── Experience.tsx    # High-level component composing the 3D scene
// │       ├── scenes/           # Specific scene configurations
// │       │   └── MainScene.tsx
// │       ├── models/           # Components representing loaded 3D models
// │       │   └── Avatar.tsx
// │       │   └── ProductModel.tsx
// │       ├── lights/           # Lighting setups
// │       │   └── StudioLights.tsx
// │       ├── controls/         # Control configurations
// │       │   └── Orbit.tsx
// │       └── helpers/          # Utility components (e.g., Grid, Axes)
// ├── hooks/
// │   └── 3d/              # Custom hooks related to 3D logic
// ├── lib/
// │   ├── three/           # Three.js specific utilities or configurations
// │   └── utils.ts         # General utilities
// └── public/
//     └── models/          # Static 3D model files (gltf, glb)
//     └── textures/        # Static texture files
// ```
//
// ## 4. Core Components & Patterns
//
// ### a) The `Canvas` Component (from R3F)
//
// This is the root of your 3D scene within React. It sets up the Three.js Renderer and Scene. [2]
//
// ```tsx
// // Example usage within a React component (e.g., app/page.tsx)
// import { Canvas } from '@react-three/fiber';
// import Experience from '@/components/3d/Experience';
//
// export default function HomePage() {
//   return (
//     <div style={{ height: '100vh', width: '100%' }}>
//       <Canvas
//         shadows // Enable shadows
//         camera={{ position:, fov: 50 }} // Configure default camera
//         gl={{ antialias: true }} // WebGL renderer options
//       >
//         <Experience />
//       </Canvas>
//     </div>
//   );
// }
// ```
//
// ### b) Declarative Scene Building
//
// Inside the `<Canvas>`, you use components that map to Three.js objects. R3F provides primitives like `<mesh>`, `<ambientLight>`, etc. [2] Drei provides higher-level abstractions. [3]
//
// ```tsx
// // Example within Experience.tsx or a scene component
// import { OrbitControls, Environment } from '@react-three/drei';
// import { useThree } from '@react-three/fiber'; // Hook to access state like camera, gl
//
// function SceneContent() {
//   // useThree hook provides access to the R3F state (scene, camera, gl, etc.)
//   const { camera, gl } = useThree();
//
//   return (
//     <>
//       {/* Drei's OrbitControls for camera interaction */}
//       <OrbitControls args={[camera, gl.domElement]} makeDefault enableZoom={false}/>
//
//       {/* Drei's Environment for realistic lighting/reflections */}
//       <Environment preset="city" />
//
//       {/* Basic Three.js light components */}
//       <ambientLight intensity={0.5} />
//       <directionalLight position={} intensity={1.5} castShadow />
//
//       {/* Basic Three.js mesh component */}
//       <mesh position={[0, 0.5, 0]} castShadow>
//         <boxGeometry args={} />
//         <meshStandardMaterial color="orange" />
//       </mesh>
//
//       {/* A floor plane */}
//       <mesh rotation={[-Math.PI / 2, 0, 0]} position={} receiveShadow>
//         <planeGeometry args={} />
//         <meshStandardMaterial color="lightgray" />
//       </mesh>
//     </>
//   );
// }
// ```
//
// ### c) Loading Models (`useGLTF` from Drei)
//
// Drei's `useGLTF` hook simplifies loading GLTF/GLB models and integrates seamlessly with React Suspense. [3]
//
// ```tsx
// // Example: components/3d/models/MyModel.tsx
// import React, { useRef } from 'react';
// import { useGLTF, Preload } from '@react-three/drei';
// import * as THREE from 'three';
// import { GLTF } from 'three-stdlib'; // Provides types for GLTF result
//
// // Define types for the specific GLTF structure (can be auto-generated with gltfjsx)
// type GLTFResult = GLTF & {
//   nodes: {
//     YourMeshName: THREE.Mesh;
//     // ... other nodes
//   };
//   materials: {
//     YourMaterialName: THREE.MeshStandardMaterial;
//     // ... other materials
//   };
// };
//
// interface MyModelProps extends JSX.IntrinsicElements['group'] {
//   modelPath: string;
// }
//
// export function MyModel({ modelPath, ...props }: MyModelProps) {
//   const group = useRef<THREE.Group>(null);
//   // Use the hook to load the GLTF file. This suspends until loaded.
//   const { nodes, materials } = useGLTF(modelPath) as GLTFResult;
//
//   return (
//     // Use the dispose={null} prop to prevent R3F from disposing geometries/materials
//     // if the model is used elsewhere or needs to persist.
//     <group ref={group} {...props} dispose={null}>
//       {/* Access nodes and materials from the loaded GLTF */}
//       <mesh
//         castShadow
//         receiveShadow
//         geometry={nodes.YourMeshName.geometry}
//         material={materials.YourMaterialName}
//         // Add transformations or other props as needed
//       />
//       {/* Add other parts of your model here */}
//     </group>
//   );
// }
//
// // Preload the model for faster loading on subsequent mounts
// useGLTF.preload('/models/myModel.glb');
// ```
// **Tip:** Use `npx gltfjsx yourModel.glb --types` to auto-generate the component and types from your GLB/GLTF file. [3]
//
// ### d) Creating Custom Reusable 3D Components
//
// Encapsulate 3D logic into standard React components.
//
// ```tsx
// // Example: components/3d/helpers/AnimatedBox.tsx
// import React, { useRef, useState } from 'react';
// import { useFrame } from '@react-three/fiber';
// import * as THREE from 'three';
//
// interface AnimatedBoxProps extends JSX.IntrinsicElements['mesh'] {
//   initialColor?: THREE.ColorRepresentation;
//   hoverColor?: THREE.ColorRepresentation;
//   rotationSpeed?: number;
// }
//
// /**
//  * A simple box mesh that rotates and changes color on hover.
//  * LLM: Modify this component to accept a 'shape' prop ('box', 'sphere', 'torus').
//  * LLM: Add a prop 'animationType' ('rotate', 'float').
//  */
// export function AnimatedBox({
//   initialColor = 'orange',
//   hoverColor = 'hotpink',
//   rotationSpeed = 0.01,
//   ...props
// }: AnimatedBoxProps) {
//   const meshRef = useRef<THREE.Mesh>(null!);
//   const [hovered, setHover] = useState(false);
//   const [active, setActive] = useState(false); // Example state
//
//   // useFrame executes code on every rendered frame
//   useFrame((state, delta) => {
//     if (meshRef.current) {
//       meshRef.current.rotation.x += rotationSpeed;
//       meshRef.current.rotation.y += rotationSpeed * 0.5;
//     }
//   });
//
//   return (
//     <mesh
//       {...props}
//       ref={meshRef}
//       scale={active ? 1.2 : 1} // Example interaction
//       onClick={(event) => setActive(!active)}
//       onPointerOver={(event) => setHover(true)}
//       onPointerOut={(event) => setHover(false)}
//     >
//       <boxGeometry args={} />
//       <meshStandardMaterial color={hovered ? hoverColor : initialColor} />
//     </mesh>
//   );
// }
// ```
//
// ## 5. LLM Optimization Guidelines
//
// To make this system easy for LLMs (and humans!) to work with:
//
// 1.  **Clear Naming:** Use descriptive names for components (`StudioLights`, `ProductViewer`), props (`modelUrl`, `enableShadows`), and variables.
// 2.  **Componentization:** Break down complex scenes (`Experience.tsx`) into smaller, single-purpose components (`Model.tsx`, `Lights.tsx`, `EnvironmentSetup.tsx`). Pass data via props.
// 3.  **Strong Typing (TypeScript):** Define interfaces for props (`interface ProductModelProps { ... }`) and complex state. This provides essential context for LLMs. Use types provided by R3F/Drei/Three (`GroupProps`, `MeshProps`, `MaterialNode`).
// 4.  **JSDoc Comments:** Add clear comments explaining:
//     *   The purpose of each component (`/** Renders the main product model */`).
//     *   The role of each prop (`@param {string} modelPath - URL to the GLB model.`).
//     *   Complex logic or hooks (`// Rotates the model on each frame`).
//     *   **Include LLM directives/hints directly in comments** (`// LLM: Add a prop 'spinAxis' to control the rotation axis.`).
// 5.  **File Structure:** Maintain the logical structure proposed above. LLMs can infer relationships based on directory layout.
// 6.  **Configuration Files:** Keep constants or configurations (like light settings, camera positions) in separate files or objects (`lib/three/config.ts`) for easy modification via prompts.
// 7.  **Provide Context in Prompts:** When prompting an LLM, provide:
//     *   The relevant file(s) or component code.
//     *   The desired outcome (e.g., "Add a hover effect to this model component").
//     *   Specify which components/props/hooks to use or modify.
//     *   Mention the file structure if relevant ("Create a new component `Floor.tsx` in `components/3d/scenes/`").
//
// ## 6. Example Implementation (Repomix Style)
//
// This section simulates the Repomix output, providing a concrete example based on the proposed structure.
//
// ```
// ================================================================
// File Summary
// ================================================================
//
// Purpose:
// --------
// Example implementation of the robust 3D integration system for Next.js/React.
// Demonstrates project structure, core components (Canvas, R3F, Drei),
// model loading, and LLM-friendly practices.
//
// ================================================================
// Directory Structure
// ================================================================
// src/
// ├── app/
// │   └── page.tsx
// │   └── layout.tsx
// │   └── globals.css
// ├── components/
// │   └── 3d/
// │       ├── Experience.tsx    # Main 3D scene composition
// │       ├── scenes/
// │       │   └── BasicScene.tsx  # Scene content (lights, models, floor)
// │       ├── models/
// │       │   └── PlaceholderModel.tsx # Simple model component
// │       └── controls/
// │           └── Orbit.tsx       # OrbitControls setup
// ├── lib/
// │   └── three/
// │       └── constants.ts    # 3D related constants
// └── public/
//     └── models/
//         └── (needs a placeholder model, e.g., cube.glb)
// package.json
// next.config.mjs
// tsconfig.json
//
// ================================================================
// Files
// ================================================================
//
// ================
// File: src/app/layout.tsx
// ================
import type { Metadata } from 'next';
import './globals.css';

export const metadata: Metadata = {
  title: 'Next.js + R3F App',
  description: 'Integrating 3D with React Three Fiber',
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  );
}

// ================
// File: src/app/globals.css
// ================
// Standard Tailwind/CSS setup
// Ensure body/html have height: 100% for full-screen canvas
html, body, #__next {
  height: 100%;
  margin: 0;
  padding: 0;
  background-color: #f0f0f0; // Example background
  overflow: hidden; // Prevent scrollbars if canvas is full screen
}

// ================
// File: src/app/page.tsx
// ================
'use client'; // R3F Canvas requires client-side rendering

import React, { Suspense } from 'react';
import { Canvas } from '@react-three/fiber';
import Experience from '@/components/3d/Experience';
import { Leva } from 'leva'; // Optional: For easy debugging controls

// LLM: Change the camera position to.
// LLM: Add performance monitoring using Drei's <PerformanceMonitor /> inside Suspense.

export default function HomePage() {
  return (
    <div style={{ height: '100vh', width: '100%' }}>
      {/* Leva panel for GUI controls - useful for debugging */}
      <Leva collapsed />

      <Canvas
        shadows // Enable shadows globally
        camera={{ position:, fov: 50 }} // Default camera settings
        gl={{ antialias: true }} // Improve visual quality
      >
        {/* Suspense is crucial for components that load assets (like useGLTF) */}
        <Suspense fallback={null}>
           {/* Experience component orchestrates the main 3D content */}
          <Experience />
        </Suspense>
      </Canvas>
    </div>
  );
}


// ================
// File: src/components/3d/Experience.tsx
// ================
import React from 'react';
import { Preload } from '@react-three/drei';
import BasicScene from './scenes/BasicScene';
import Orbit from './controls/Orbit';

/**
 * Experience Component
 * Top-level component orchestrating the 3D scene within the Canvas.
 * It typically includes controls, environment setup, and the main scene content.
 * LLM: Add postprocessing effects like Bloom using '@react-three/postprocessing'.
 * LLM: Import and use a different scene component from './scenes/'.
 */
export default function Experience() {
  return (
    <>
      {/* Orbit controls for camera manipulation */}
      <Orbit />

      {/* Main scene content */}
      <BasicScene />

      {/* Preload assets for smoother experience */}
      <Preload all />
    </>
  );
}


// ================
// File: src/components/3d/scenes/BasicScene.tsx
// ================
import React from 'react';
import { Environment, Grid } from '@react-three/drei';
import { PlaceholderModel } from '../models/PlaceholderModel';
import { useControls } from 'leva'; // Optional: For debugging

// LLM: Change the environment preset to 'sunset'.
// LLM: Add a directional light pointing from [-5, 5, -5].
// LLM: Replace PlaceholderModel with a different model component from '../models/'.

/**
 * BasicScene Component
 * Contains the primary visual elements of the 3D scene like models, lights, floor, environment.
 */
export default function BasicScene() {
  // Example Leva controls for debugging
  const { gridSize, gridColor, modelPosition } = useControls('Scene Settings', {
    gridSize: { value: 10, min: 1, max: 50, step: 1 },
    gridColor: '#888888',
    modelPosition: { value: [0, 0.5, 0], step: 0.1 },
  });

  return (
    <>
      {/* Environment lighting and background */}
      <Environment preset="city" background blur={0.5} />

      {/* Basic lighting */}
      <ambientLight intensity={0.6} />
      <directionalLight
        position={}
        intensity={1.5}
        castShadow
        shadow-mapSize-width={1024}
        shadow-mapSize-height={1024}
        shadow-camera-far={50}
        shadow-camera-left={-10}
        shadow-camera-right={10}
        shadow-camera-top={10}
        shadow-camera-bottom={-10}
      />

      {/* Grid helper */}
      <Grid
        args={[gridSize, gridSize]}
        cellSize={0.5}
        cellThickness={1}
        cellColor={gridColor}
        sectionSize={2}
        sectionThickness={1.5}
        sectionColor={'#444444'}
        fadeDistance={25}
        fadeStrength={1}
        infiniteGrid
      />

      {/* Load the placeholder model */}
      <PlaceholderModel position={modelPosition as [number, number, number]} />

      {/* A simple floor plane */}
      <mesh rotation={[-Math.PI / 2, 0, 0]} position={} receiveShadow>
        <planeGeometry args={} />
        {/* Use shadow-only material for performance if floor color isn't needed */}
        <shadowMaterial transparent opacity={0.4} />
         {/* <meshStandardMaterial color="lightgray" /> */}
      </mesh>
    </>
  );
}


// ================
// File: src/components/3d/models/PlaceholderModel.tsx
// ================
import React, { useRef } from 'react';
import { useFrame } from '@react-three/fiber';
import * as THREE from 'three';

// LLM: Replace the boxGeometry with a sphereGeometry.
// LLM: Make the rotation speed configurable via a 'speed' prop.
// LLM: Add a hover effect that scales the model up slightly.

/**
 * PlaceholderModel Component
 * A simple rotating cube mesh serving as a placeholder.
 * Replace this with components generated by gltfjsx or custom models.
 */
export function PlaceholderModel(props: JSX.IntrinsicElements['mesh']) {
  const meshRef = useRef<THREE.Mesh>(null!);

  useFrame((state, delta) => {
    if (meshRef.current) {
      meshRef.current.rotation.y += delta * 0.5; // Rotate the model
    }
  });

  return (
    <mesh {...props} ref={meshRef} castShadow receiveShadow>
      <boxGeometry args={} />
      <meshStandardMaterial color="royalblue" roughness={0.5} metalness={0.5}/>
    </mesh>
  );
}

// // --- GLTF Loading Example (commented out) ---
// import { useGLTF } from '@react-three/drei';
// import { GLTF } from 'three-stdlib';

// type GLTFResult = GLTF & {
//   nodes: { MeshName: THREE.Mesh };
//   materials: { MaterialName: THREE.MeshStandardMaterial };
// };
// export function LoadedModel(props: JSX.IntrinsicElements['group']) {
//   const { nodes, materials } = useGLTF('/models/your-model.glb') as GLTFResult;
//   return (
//     <group {...props} dispose={null}>
//       <mesh geometry={nodes.MeshName.geometry} material={materials.MaterialName} />
//     </group>
//   );
// }
// useGLTF.preload('/models/your-model.glb');
// // --- End GLTF Loading Example ---


// ================
// File: src/components/3d/controls/Orbit.tsx
// ================
import { OrbitControls } from '@react-three/drei';
import { useThree } from '@react-three/fiber';

/**
 * Orbit Component
 * Sets up Drei's OrbitControls for camera interaction.
 * LLM: Disable zooming by setting enableZoom={false}.
 * LLM: Limit vertical rotation using minPolarAngle and maxPolarAngle.
 */
export default function Orbit() {
  const { camera, gl } = useThree();
  return (
    <OrbitControls
        args={[camera, gl.domElement]} // Connect controls to camera and renderer DOM element
        makeDefault // Sets these controls as the default interaction
        enablePan={true}
        enableZoom={true}
        enableRotate={true}
        // Example limits:
        // minPolarAngle={Math.PI / 4}
        // maxPolarAngle={Math.PI / 1.5}
        // minAzimuthAngle={-Math.PI / 4}
        // maxAzimuthAngle={Math.PI / 4}
      />
  );
}


// ================
// File: src/lib/three/constants.ts
// ================
/**
 * Constants for 3D configuration.
 * Useful for centralizing values that might be reused or prompted for changes.
 * LLM: Change the DEFAULT_CAMERA_FOV to 60.
 */

export const DEFAULT_CAMERA_FOV = 50;
export const MAX_SHADOW_MAP_SIZE = 2048;

// Add other constants as needed (e.g., material properties, animation speeds)


// ================
// File: package.json
// ================
// {
//   "name": "next-r3f-project",
//   "version": "0.1.0",
//   "private": true,
//   "scripts": {
//     "dev": "next dev",
//     "build": "next build",
//     "start": "next start",
//     "lint": "next lint"
//   },
//   "dependencies": {
//     "@react-three/drei": "^9.109.2", // Use latest
//     "@react-three/fiber": "^8.16.8", // Use latest
//     "leva": "^0.9.35", // Optional for controls
//     "next": "15.0.0-rc.0", // Or latest stable
//     "react": "19.0.0-rc-f994737d14-20240522", // Or latest stable React 19
//     "react-dom": "19.0.0-rc-f994737d14-20240522", // Or latest stable React 19
//     "three": "^0.167.0" // Use latest
//   },
//   "devDependencies": {
//     "@types/node": "^20",
//     "@types/react": "^18", // Adjust if specific React 19 types are available/needed
//     "@types/react-dom": "^18",// Adjust if specific React 19 types are available/needed
//     "@types/three": "^0.167.0", // Use latest matching three
//     "eslint": "^8",
//     "eslint-config-next": "15.0.0-rc.0",
//     "postcss": "^8",
//     "tailwindcss": "^3.4.1", // If using Tailwind
//     "typescript": "^5"
//   }
// }


// ================
// File: next.config.mjs
// ================
/** @type {import('next').NextConfig} */
const nextConfig = {
  // Required for R3F/Three.js: Allows transpiling their ESM modules
  transpilePackages: ['three', '@react-three/drei'],
  // Optional: If using GLSL shaders
  // webpack: (config) => {
  //   config.module.rules.push({
  //     test: /\.(glsl|vs|fs|vert|frag)$/,
  //     exclude: /node_modules/,
  //     use: ['raw-loader', 'glslify-loader'],
  //   });
  //   return config;
  // },
};

export default nextConfig;


// ================
// File: tsconfig.json
// ================
// {
//   "compilerOptions": {
//     "lib": ["dom", "dom.iterable", "esnext"],
//     "allowJs": true,
//     "skipLibCheck": true,
//     "strict": true,
//     "noEmit": true,
//     "esModuleInterop": true,
//     "module": "esnext",
//     "moduleResolution": "bundler",
//     "resolveJsonModule": true,
//     "isolatedModules": true,
//     "jsx": "preserve",
//     "incremental": true,
//     "plugins": [
//       {
//         "name": "next"
//       }
//     ],
//     "paths": {
//       "@/*": ["./src/*"]
//     }
//   },
//   "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
//   "exclude": ["node_modules"]
// }
// ```
//
// ---
//
// ## 7. Advanced Topics (Pointers)
//
// - **Post-processing:** Use `@react-three/postprocessing` for effects like Bloom, Depth of Field, SSAO. [4]
// - **Performance Optimization:**
//     - Instancing (`<Instances>`, `<Merged>`) for large numbers of similar objects. [3]
//     - BVH (`<Bvh>`) for faster raycasting. [3]
//     - Texture optimization (compression, resolution).
//     - Level of Detail (LOD) (`<Detailed>`). [3]
//     - Freezing static shadows (`<BakeShadows>`). [3]
// - **Physics:** Integrate libraries like `react-three-rapier` or `react-three-cannon`.
// - **State Management:** Use Zustand, Jotai, or React Context to manage complex 3D state, passing necessary values down into the `<Canvas>`.
// - **Shaders:** Write custom shaders using `shaderMaterial` from Drei or directly with `THREE.ShaderMaterial`. [3, 1]
//
// ## 8. Conclusion
//
// This document provides a foundation for building 3D experiences in Next.js/React. By leveraging R3F and Drei, and following the proposed structure and LLM optimization guidelines, you can create complex, performant, and maintainable 3D integrations more efficiently, whether coding manually or prompting an AI assistant. Remember to consult the official documentation for R3F [2], Drei [3], and Three.js [1] for more in-depth information.
//
// ---
//
// ## Citations & Further Reading
// 1.  **Three.js Documentation:** [https://threejs.org/docs/](https://threejs.org/docs/)
// 2.  **React Three Fiber (R3F) Documentation:** [https://docs.pmnd.rs/react-three-fiber/](https://docs.pmnd.rs/react-three-fiber/)
// 3.  **Drei Documentation:** [https://drei.pmnd.rs/](https://drei.pmnd.rs/)
// 4.  **React Postprocessing Documentation:** [https://docs.pmnd.rs/react-postprocessing/](https://docs.pmnd.rs/react-postprocessing/)
// 5.  **gltfjsx Tool:** [https://github.com/pmndrs/gltfjsx](https://github.com/pmndrs/gltfjsx)
